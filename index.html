<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.4" />
<title>Processing Shader Examples</title>
<style type="text/css">
/* Sans-serif font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
div#toctitle,
span#author, span#revnumber, span#revdate, span#revremark,
div#footer {
  font-family: Arial,Helvetica,sans-serif;
}

/* Serif font. */
div.sectionbody {
  font-family: Georgia,"Times New Roman",Times,serif;
}

/* Monospace font. */
tt {
  font-size: inherit;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

tt {
  font-size: inherit;
  color: navy;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

pre {
  padding: 0;
  margin: 0;
}

span#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
span#email {
}
span#revnumber, span#revdate, span#revremark {
}

div#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
div#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
div#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

div#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.tableblock, div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #777777;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  div#footer-badges { display: none; }
}

div#toc {
  margin-bottom: 2.5em;
}

div#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }
</style>
<script type="text/javascript">
/*<![CDATA[*/
window.onload = function(){asciidoc.footnotes();}
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([2-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  var cont = document.getElementById("content");
  var noteholder = document.getElementById("footnotes");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      // Use [\s\S] in place of . so multi-line matches work.
      // Because JavaScript has no s (dotall) regex flag.
      note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      spans[i].innerHTML =
        "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
        "' title='View footnote' class='footnote'>" + n + "</a>]";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
}

}
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>Processing Shader Examples</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph"><p>Welcome to Processing Shader Examples! This is where I try to learn about shaders using Processing and the Processing GLGraphics library (<a href="http://glgraphics.sourceforge.net/">http://glgraphics.sourceforge.net/</a>) and record my experiments and the lessons I learn. The repo for this project is here: <a href="https://github.com/atduskgreg/Processing-Shader-Examples">https://github.com/atduskgreg/Processing-Shader-Examples</a> Each sub-directory of this repo includes a shader example written in Processing along with a description.asciidoc file with notes about that particular example. I&#8217;ve also included all of the description files in this README for convenience (though that doesn&#8217;t seem to actually work on the project homepage in GitHub; if you&#8217;re reading this there, head to <a href="http://atduskgreg.github.com/Processing-Shader-Examples">http://atduskgreg.github.com/Processing-Shader-Examples</a> to see the real version).</p></div>
<div class="paragraph"><p>Right now, I&#8217;m mainly working from Graphics Shaders: Theory and Practice by Mike Bailey and Steve Cunningham (<a href="http://www.amazon.com/Graphics-Shaders-Practice-Mike-Bailey/dp/1568813341">http://www.amazon.com/Graphics-Shaders-Practice-Mike-Bailey/dp/1568813341</a>). Andres Colubri, author of the GLGraphics library, was an enormous help in getting started especially a session he taught at ITP Camp 2011 on the topic of Image Processing with Shaders in Processing. I&#8217;ve included the notes from that session here as well. It acts as a kind of introduction to the rest of this material, so we begin with it.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_image_filters_and_3d_effects_with_glsl_by_andres_colubri">Image Filters and 3D Effects with GLSL by Andres Colubri</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_on_the_cpu">On the CPU</h3>
<div class="ulist"><ul>
<li>
<p>
define geometry
</p>
</li>
<li>
<p>
beginShape() etc
</p>
</li>
<li>
<p>
define vertices:
</p>
<div class="ulist"><ul>
<li>
<p>
vertex coords
</p>
</li>
<li>
<p>
colors
</p>
</li>
<li>
<p>
connectivity
</p>
</li>
<li>
<p>
normals
</p>
</li>
<li>
<p>
texturecoords
</p>
</li>
<li>
<p>
textures
</p>
</li>
</ul></div>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_on_the_gpu">On the GPU</h3>
<div class="ulist"><ul>
<li>
<p>
GOAL: convert geometry into pixels
</p>
</li>
<li>
<p>
Vertex Shader:
</p>
<div class="ulist"><ul>
<li>
<p>
convert coordinates to screen space
</p>
</li>
<li>
<p>
takes 3D geometry and outputs 2D geometry
</p>
</li>
</ul></div>
</li>
<li>
<p>
Fragment/Pixel shader:
</p>
<div class="ulist"><ul>
<li>
<p>
converts 2D geometry to an array of pixels: rasterization
</p>
</li>
<li>
<p>
blending algorithms
</p>
</li>
<li>
<p>
lighting is applied
</p>
</li>
<li>
<p>
leads to final pixel color
</p>
</li>
</ul></div>
</li>
<li>
<p>
GPU is highly parallel
</p>
<div class="ulist"><ul>
<li>
<p>
can draw every pixel simultaneously
</p>
</li>
<li>
<p>
GPU has many cores, hundreds
</p>
</li>
<li>
<p>
NVidia 5706TX has 512 cores
</p>
</li>
</ul></div>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_play_with_shaders_in_processing">Play with Shaders in Processing</h3>
<div class="ulist"><ul>
<li>
<p>
Andres' GLGraphics library: <a href="http://glgraphics.sourceforge.net">http://glgraphics.sourceforge.net</a>
</p>
<div class="ulist"><ul>
<li>
<p>
works with Processing 1.5x not 2.0
</p>
</li>
</ul></div>
</li>
<li>
<p>
GLGraphics &gt; Examples &gt; Textures &gt; BasicUse, etc.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_use_shaders_for_2d_image_effects_post_processing">Use Shaders for 2D Image Effects/Post-processing</h3>
<div class="ulist"><ul>
<li>
<p>
Send an image to the GPU
</p>
<div class="ulist"><ul>
<li>
<p>
as a textured quad:
</p>
</li>
</ul></div>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><tt>beginShape(QUAD);
  texture(...);
  vertex(...);
  vertex(...);
  vertex(...);
  vertex(...);
endShape();</tt></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
draw the quad covering the whole screen
</p>
</li>
<li>
<p>
using orthographic projection
</p>
</li>
<li>
<p>
the vertex shader does nothing: "trivial"
</p>
</li>
<li>
<p>
the pixel shader is the interesting part
</p>
<div class="ulist"><ul>
<li>
<p>
does a texture lookup to get the color of each pixel
</p>
</li>
<li>
<p>
can apply transformations per pixel
</p>
</li>
<li>
<p>
custom transformation is written in GLSL
</p>
</li>
</ul></div>
</li>
<li>
<p>
result of shader operations gets copied into a new texture
</p>
<div class="ulist"><ul>
<li>
<p>
has to be a new texture or you get problems
</p>
</li>
<li>
<p>
use ping-pong technique of swapping back and forth between two textures on alternating frames
</p>
</li>
</ul></div>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_actually_writing_shaders">Actually Writing Shaders</h3>
<div class="ulist"><ul>
<li>
<p>
glsl file w/an XML filter file for GLGraphics
</p>
<div class="ulist"><ul>
<li>
<p>
filter file combines vertex/fragment shaders and declares parameters
</p>
</li>
</ul></div>
</li>
<li>
<p>
example of swapping red and green component of an image on the cpu:
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><tt>PImage img;
PImage dest;

void setup(){
  size(1600,600, JAVA2D);
  frameRate(180);

  img = loadImage("landscape.jpg");
  img.loadPixels();

  dest = createImage(800, 600, RGB);
  dest.loadPixels();
}

void draw(){
    for(int i = 0; i &lt; img.width * img.height; i++){
      color c = img.pixels[i];
      dest.pixels[i] = color(green(c), red(c), blue(c), alpha(c));
    }



    image(img, 0,0);
    image(dest,800,0);

    println(frameRate);
}</tt></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
Equivalent example on the GPU:
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><tt>import processing.opengl.*;
import codeanticode.glgraphics.*;

GLTexture texSource;
GLTexture texDestination;

GLTextureFilter colorSwap;

void setup(){
  size(1600, 600, GLConstants.GLGRAPHICS);
  frameRate(180);

  texSource = new GLTexture(this, "landscape.jpg");
  texDestination = new GLTexture(this, texSource.width, texSource.height);
  colorSwap = new GLTextureFilter(this, "colorSwap.xml");
}

void draw(){
  colorSwap.apply(texSource, texDestination);
  // synonym:
  // texSource.filter(colorSwap, texDestination);

  image(texSource, 0,0);
  image(texDestination, 800,0);

  println(frameRate);
}</tt></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
With a filter file ("colorSwap.xml") that looks like this:
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><tt>&lt;filter name="colorSwap"&gt;
  &lt;description&gt;Reverse red and green components of each pixel&lt;/description&gt;
  &lt;fragment&gt;colorSwap.glsl&lt;/fragment&gt;
  &lt;textures input="1" output="1"&gt;&lt;/textures&gt;
&lt;/filter&gt;</tt></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
and a fragment shader ("colorSwap.glsl") that looks like this:
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><tt>uniform sampler2D src_tex_unit0;

void main(void){
  // get the location of the current pixel
  // in the input texture
  vec2 tex_coord = gl_TexCoord[0].st;

  // read the color of the current pixel out of the
  // input texture
  vec4 src_color = texture2D(src_tex_unit0, tex_coord).rgba;

  // output:
  // set color of the fragment
  gl_FragColor = vec4(src_color.g, src_color.r, src_color.b, src_color.a);
}</tt></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
GPU version runs 6 times faster at least
</p>
</li>
<li>
<p>
now, passing arguments into the shader
</p>
<div class="ulist"><ul>
<li>
<p>
in draw() add calls to setParameterValue()
</p>
</li>
</ul></div>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><tt>void draw(){
  // NEW LINES: pass arguments into the shader
  colorSwap.setParameterValue("scaledMouseX", map(mouseX, 0, width, 0, 1));
  colorSwap.setParameterValue("scaledMouseY", map(mouseY, 0, height, 0, 1));

  colorSwap.apply(texSource, texDestination);
  // synonym:
  // texSource.filter(colorSwap, texDestination);

  image(texSource, 0,0);
  image(texDestination, 800,0);

  println(frameRate);
}</tt></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
pass these parameters through in the xml:
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><tt>&lt;filter name="colorSwap"&gt;
  &lt;description&gt;Reverse red and green components of each pixel&lt;/description&gt;
  &lt;fragment&gt;colorSwap.glsl&lt;/fragment&gt;
  &lt;textures input="1" output="1"&gt;&lt;/textures&gt;
  &lt;parameters&gt;
    &lt;parameter type="float" name="scaledMouseX" label=""&gt;1&lt;/parameter&gt;
    &lt;parameter type="float" name="scaledMouseY" label=""&gt;1&lt;/parameter&gt;
  &lt;/parameters&gt;
&lt;/filter&gt;</tt></pre>
</div></div>
<div class="ulist"><ul>
<li>
<p>
and use them in the shader:
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content">
<pre><tt>uniform sampler2D src_tex_unit0;
uniform float scaledMouseX;
uniform float scaledMouseY;

void main(void){
  // get the location of the current pixel
  // in the input texture
  vec2 tex_coord = gl_TexCoord[0].st;

  // read the color of the current pixel out of the
  // input texture
  vec4 src_color = texture2D(src_tex_unit0, tex_coord).rgba;

  // output:
  // set color of the fragment
  gl_FragColor = vec4(src_color.g * scaledMouseX, src_color.r * scaledMouseY, src_color.b, src_color.a);
}</tt></pre>
</div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_basic_vertex_shader">Basic Vertex Shader</h2>
<div class="sectionbody">
<div class="paragraph"><p>This example reproduces the standard lighting setup on a rotating cube using a vertex shader and a very simple fragment shader.</p></div>
<div class="paragraph"><p>Code here: <a href="https://github.com/atduskgreg/Processing-Shader-Examples/tree/master/basic_vertex_shader">https://github.com/atduskgreg/Processing-Shader-Examples/tree/master/basic_vertex_shader</a>. And reproduced in full after the notes.</p></div>
<div class="paragraph"><p>When running it looks like this:</p></div>
<div class="paragraph"><p><span class="image">
<img src="basic_vertex_shader/spinning_cube.jpg" alt="basic_vertex_shader/spinning_cube.jpg" />
</span></p></div>
<div class="sect2">
<h3 id="_initializing_shaders_directly_in_glgraphics">Initializing Shaders directly in GLGraphics</h3>
<div class="paragraph"><p>You can work with shaders in GLGraphics without having to use an xml file. See line 9 of the sketch where the shader is declared with paths to the vertex and fragment shaders (relative to the sketch&#8217;s data directory):</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>vertexShader = new GLSLShader(this, "sphereShading.vert", "sphereShading.frag");</tt></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_glgraphics_renderer_causes_coordinate_confusion">GLGraphics Renderer Causes Coordinate Confusion</h3>
<div class="paragraph"><p>If you use the GLGraphics renderer as is demonstrated in some of the GLGraphics examples, it will play havoc with pushMatrix(), popMatrix(), translate(), etc. You can still bind shaders for rendering without the GLGraphics renderer (see lines 23-25) thusly:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>vertexShader.start();
box(300);
vertexShader.stop();</tt></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_a_vertex_shader_that_reproduces_standard_lighting">A Vertex Shader That Reproduces Standard Lighting</h3>
<div class="paragraph"><p>The vertex shader is a bit complicated. All it&#8217;s really doing is reproducing the standard lighting model of OpenGL. It sets a fixed light position:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>vec3 LightPos   = vec3(3., 5., 10.);</tt></pre>
</div></div>
<div class="paragraph"><p>then calculates the normals for every vertex:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>vec3 transNorm  = normalize(gl_NormalMatrix * gl_Normal);</tt></pre>
</div></div>
<div class="paragraph"><p>and then uses the combination of those two to calculate the intensity of the light at every vertex (the dot product gives you the portion of the light vector hits the vertex along its normal, i.e. that actually shines on it):</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>vec3 ECposition = vec3(gl_ModelViewMatrix * gl_Vertex);
LightIntensity  = dot(normalize( LightPos - ECposition ), transNorm);
LightIntensity  = abs(LightIntensity);</tt></pre>
</div></div>
<div class="paragraph"><p>ECposition is the only confusing bit here. It represents the vertex coordinate transformed from world space to the coordinates of the current point of view. After it&#8217;s calculated this LightIntensity variable doesn&#8217;t get used until the fragment shader, where it&#8217;s multiplied by the pixel&#8217;s color to achieve the shading effect.</p></div>
</div>
<div class="sect2">
<h3 id="_processing_8217_s_fill_sets_gl_color">Processing&#8217;s fill() sets gl_Color</h3>
<div class="paragraph"><p>Any color you set with fill() in Processing will come through as the gl_Color in the vertex shader. The vertex shader has to declare color as a varying variable and set it based on gl_Color in order to pass it through to the fragment shader.</p></div>
</div>
<div class="sect2">
<h3 id="_a_simple_fragment_shader">A Simple Fragment Shader</h3>
<div class="paragraph"><p>The fragment shader here is incredibly simple, just one step above a pass-through. All it does is set the color of each pixel by multiplying the light intensity (as calculated in the vertex shader) by the color. All the pixels' alphas are set to 1 for fully opaque. The LightInensity and color are declared as varying variables come so they can come in from the vertex shader.</p></div>
</div>
<div class="sect2">
<h3 id="_code">Code</h3>
<div class="sect3">
<h4 id="_basic_vertex_shader_pde">basic_vertex_shader.pde</h4>
<div class="listingblock">
<div class="content">
<pre><tt>import processing.opengl.*;
import codeanticode.glgraphics.*;

GLSLShader vertexShader;

void setup() {
  size(800, 600, GLConstants.GLGRAPHICS);

  vertexShader = new GLSLShader(this, "sphereShading.vert", "sphereShading.frag");
  noStroke();
}

float y = 0;

void draw() {
  background(0);
  fill(255, 255*0.5, 0);

  pushMatrix();
    translate(width/2, height/2, 0);
    rotateY(y+=0.01);

    vertexShader.start();
    box(300);
    vertexShader.stop();
  popMatrix();
}</tt></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_sphereshading_vert">sphereShading.vert</h4>
<div class="listingblock">
<div class="content">
<pre><tt>varying vec4 color;
varying float LightIntensity;

void main(void){
  vec3 LightPos   = vec3(3., 5., 10.);
  vec3 transNorm  = normalize(gl_NormalMatrix * gl_Normal);
  vec3 ECposition = vec3(gl_ModelViewMatrix * gl_Vertex);
  LightIntensity  = dot(normalize( LightPos - ECposition ), transNorm);
  LightIntensity  = abs(LightIntensity);

  color           = gl_Color;
  gl_Position     = gl_ModelViewProjectionMatrix * gl_Vertex;
}</tt></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_sphereshading_frag">sphereShading.frag</h4>
<div class="listingblock">
<div class="content">
<pre><tt>varying vec4 color;
varying float LightIntensity;

void main(void)
{
    gl_FragColor = vec4(LightIntensity * color.rgb, 1.);
}</tt></pre>
</div></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_interactive_inputs_to_a_shader">Interactive Inputs to a Shader</h2>
<div class="sectionbody">
<div class="paragraph"><p>This example shows how to pass interactive inputs into a shader from Processing. It builds off of the Basic Vertex Shader example above. It moves the position of the lighting source illuminating a sphere based on the position of the user&#8217;s mouse.</p></div>
<div class="paragraph"><p>Code here: <a href="https://github.com/atduskgreg/Processing-Shader-Examples/tree/master/basic_vertex_shader_interactive">https://github.com/atduskgreg/Processing-Shader-Examples/tree/master/basic_vertex_shader_interactive</a>. And reproduced in full after the notes.</p></div>
<div class="sect2">
<h3 id="_set_uniforms_in_processing">Set Uniforms in Processing</h3>
<div class="paragraph"><p>"Uniform" variables in a shader are ones that will be the same for every vertex or fragment processed by the shader. Any variable coming in from outside the shaders, i.e. from user input, will inherently be the same for all vertices and fragments, hence they are all declared as uniforms inside the shader. GLGraphics provides a bunch of functions for setting these in Processing in the form of shader.setXXXUniform(), where XXX specifies the type of the variable being set, float, Vec, int, etc. Here we&#8217;re using floats:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>vertexShader.start();
  vertexShader.setFloatUniform("mouseX", map(mouseX, 0, width, 0, 200));
  vertexShader.setFloatUniform("mouseY", map(mouseY, 0, height, 200, 0));</tt></pre>
</div></div>
<div class="paragraph"><p>The first argument here sets up the name of the uniform inside the shader. The second argument is the value. Note that it is very important that you call setFloatUniform() and its siblings between shader.start() and shader.end(). It will not work otherwise and the error will be obscure.</p></div>
</div>
<div class="sect2">
<h3 id="_use_uniforms_in_the_shader">Use Uniforms in the Shader</h3>
<div class="paragraph"><p>Uniforms get declared like this in the shader (in this case in the vertex shader, sphereShading.vert):</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>uniform float mouseX;
uniform float mouseY;</tt></pre>
</div></div>
<div class="paragraph"><p>and then used like any other variable:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>vec3 LightPos   = vec3(mouseX, mouseY, 10.);</tt></pre>
</div></div>
<div class="paragraph"><p>In this case, we&#8217;re using the x- and y-coordinates of the mouse to set the x- and y-coordinates of the light position, giving the illusion that the light source is following the user&#8217;s mouse:</p></div>
<div class="paragraph"><p><span class="image">
<img src="basic_vertex_shader_interactive/user_controlled_light.jpg" alt="basic_vertex_shader_interactive/user_controlled_light.jpg" />
</span></p></div>
</div>
<div class="sect2">
<h3 id="_code_2">Code</h3>
<div class="sect3">
<h4 id="_basic_vertex_shader_interactive_pde">basic_vertex_shader_interactive.pde</h4>
<div class="listingblock">
<div class="content">
<pre><tt>import processing.opengl.*;
import codeanticode.glgraphics.*;

GLSLShader vertexShader;

void setup() {
  size(800, 600, GLConstants.GLGRAPHICS);

  vertexShader = new GLSLShader(this, "sphereShading.vert", "sphereShading.frag");
  noStroke();
}

void draw() {
  background(0);
  fill(255, 255*0.5, 0);

  pushMatrix();
    translate(width/2, height/2, 0);

    vertexShader.start();
        vertexShader.setFloatUniform("mouseX", map(mouseX, 0, width, 0, 200));
        vertexShader.setFloatUniform("mouseY", map(mouseY, 0, height, 200, 0));
        sphere(200);
    vertexShader.stop();
  popMatrix();
}</tt></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_sphereshading_vert_2">sphereShading.vert</h4>
<div class="listingblock">
<div class="content">
<pre><tt>varying vec4 color;
varying float LightIntensity;
uniform float mouseX;
uniform float mouseY;

void main(void){
  vec3 LightPos   = vec3(mouseX, mouseY, 10.);
  vec3 transNorm  = normalize(gl_NormalMatrix * gl_Normal);
  vec3 ECposition = vec3(gl_ModelViewMatrix * gl_Vertex);
  LightIntensity  = dot(normalize( LightPos - ECposition ), transNorm);
  LightIntensity  = abs(LightIntensity);

  color           = gl_Color;
  gl_Position     = gl_ModelViewProjectionMatrix * gl_Vertex;
}</tt></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_sphereshading_frag_2">sphereShading.frag</h4>
<div class="listingblock">
<div class="content">
<pre><tt>varying vec4 color;
varying float LightIntensity;

void main(void)
{
    gl_FragColor = vec4(LightIntensity * color.rgb, 1.);
}</tt></pre>
</div></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_a_vertex_shader_to_move_vertices">Using a Vertex Shader to Move Vertices</h2>
<div class="sectionbody">
<div class="paragraph"><p>This example uses the vertex shader to move the actual position of vertices rather than just their color. It also shows how to draw a plane using triangle strips in Processing. Thanks to Andres Colubri for help debugging!</p></div>
<div class="paragraph"><p>Code here: <a href="https://github.com/atduskgreg/Processing-Shader-Examples/tree/master/vertex_shader_ripple_plane">https://github.com/atduskgreg/Processing-Shader-Examples/tree/master/vertex_shader_ripple_plane</a>. And reproduced in full after the notes.</p></div>
<div class="paragraph"><p>When running it looks like this:</p></div>
<div class="paragraph"><p><span class="image">
<img src="vertex_shader_ripple_plane/vertex_shader_ripple_plane.jpg" alt="vertex_shader_ripple_plane/vertex_shader_ripple_plane.jpg" />
</span></p></div>
<div class="sect2">
<h3 id="_altering_geometry_and_re_calculating_normals">Altering Geometry and Re-calculating Normals</h3>
<div class="paragraph"><p>This shader moves the points on a plane up and down based on the position of the mouse. It calculates the Z position of each point as a kind of sine wave of the point&#8217;s position on the plane (multiplying by the mouseX position which is passed in as a uniform variable to make it interactive):</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>thisPos.z += mouseX * sin(thisX*thisX + thisY*thisY);</tt></pre>
</div></div>
<div class="paragraph"><p>Since this changes the angle of the vertex relative to the light source, we have to recalculate the vertex&#8217;s normals so that lighting will still work on it correctly:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>thisNorml.x = 2. * 0.3 * thisX * cos(thisX*thisX + thisY*thisY);
thisNorml.y = 2. * 0.3 * thisY * cos(thisX*thisX + thisY*thisY);
thisNorml.z = 1.;</tt></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_coordinate_sizzling">Coordinate Sizzling</h3>
<div class="paragraph"><p>In looking at this shader, Andrew suggested something I could do to make it more efficient. Instead of constantly accessing the x- and y-coordinates of the current vertex as separate variables, I could use a technique he called "coordinate sizzling" to access multiple of them at once.</p></div>
<div class="paragraph"><p>Instead of doing something like this (what I currently do):</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>float thisX = thisPos.x;
float thisY = thisPos.y;
thisPos.z += mouseX * sin(thisX*thisX + thisY*thisY);</tt></pre>
</div></div>
<div class="paragraph"><p>I could do this:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>thisPos.z += 20.0 * sin(dot(thisPos.xy, thisPos.xy)</tt></pre>
</div></div>
<div class="paragraph"><p>This second version accesses both the x- and y-coordinates simultaneously. Apparently, it&#8217;s more efficient.</p></div>
</div>
<div class="sect2">
<h3 id="_drawing_a_plane_with_a_triangle_strip">Drawing a Plane with a Triangle Strip</h3>
<div class="paragraph"><p>In introducing this shader example, Bailey and Cunningham say that they applied it to a quad defined "from -5 to 5 with 20 subdivisions". This was rather vague so I experimented a bit with Processing&#8217;s geometry options. Just drawing a simple four-vertex quad with "beginShape(QUADS)" didn&#8217;t work, the shader had no visible effect. So I tried again, this time with a TRIANGLE_STRIP. When I did that the shader started taking effect. Since it&#8217;s a vertex shader, it only operates on vertices, I guess, and so needed more vertices to manipulate. The distortion still seems a big, er, pointy, though so I think I&#8217;m not quite doing something right still. The illustration in the book had a nice ripples in water quality to it.</p></div>
</div>
<div class="sect2">
<h3 id="_code_3">Code</h3>
<div class="sect3">
<h4 id="_vertex_shader_ripple_plane_pde">vertex_shader_ripple_plane.pde</h4>
<div class="listingblock">
<div class="content">
<pre><tt>import processing.opengl.*;
import codeanticode.glgraphics.*;

GLSLShader vertexShader;

void setup() {
  size(800, 600, GLConstants.GLGRAPHICS);

  vertexShader = new GLSLShader(this, "planeRippler.vert", "planeRippler.frag");
  noStroke();
}

void draw() {
  background(0);
  fill(255, 255*0.5, 0);

  vertexShader.start();
  vertexShader.setFloatUniform("mouseX", map(mouseX, 0, width, 0, 100));

  beginShape(TRIANGLE_STRIP);

  for (int i =0; i &lt;11; i ++) {
    float startX = width/2 - 200;
    float startY =  height/4;
    int triangleHeight = 20;
    vertex(startX, startY + (i * triangleHeight), (i * triangleHeight));
    vertex(startX + 400, startY + (i* triangleHeight ), (i * triangleHeight));
  }
  endShape(CLOSE);

  vertexShader.stop();
}</tt></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_planerippler_vert">planeRippler.vert</h4>
<div class="listingblock">
<div class="content">
<pre><tt>varying vec3 myColor;
varying float LightIntensity;
uniform float mouseX;

void main(void){
  vec3 thisNorml;

  vec4 thisPos = gl_Vertex;
  myColor = gl_Color.rgb;

  float thisX = thisPos.x;
  float thisY = thisPos.y;

  thisPos.z += mouseX * sin(thisX*thisX + thisY*thisY);
  // alternately, "coordinate sizzling":
  // thisPos.z += 20.0 * sin(dot(thisPos.xy, thisPos.xy));

  vec3 LightPos = vec3(0., 10., 0.);

  thisNorml.x = 2. * 0.3 * thisX * cos(thisX*thisX + thisY*thisY);
  thisNorml.y = 2. * 0.3 * thisY * cos(thisX*thisX + thisY*thisY);
  thisNorml.z = 1.;

  vec3 myNorml = normalize(thisNorml);

  vec3 ECpos = vec3(gl_ModelViewMatrix * thisPos);

  LightIntensity = dot(normalize(LightPos - ECpos), myNorml);
  LightIntensity = 0.3 + abs(LightIntensity);
  LightIntensity = clamp(LightIntensity, 0., 1.);

  gl_Position     = gl_ModelViewProjectionMatrix * thisPos;
}</tt></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_planerippler_frag">planeRippler.frag</h4>
<div class="listingblock">
<div class="content">
<pre><tt>varying vec3 myColor;
varying float LightIntensity;

void main(void)
{
    gl_FragColor = vec4(LightIntensity * myColor.rgb, 1.);
}</tt></pre>
</div></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sharpen_shader">Sharpen Shader</h2>
<div class="sectionbody">
<div class="paragraph"><p>This shader sharpens an image. <a href="http://farm8.staticflickr.com/7219/7336302418_01e54d7727.jpg">See the results</a>. It is also a good example of a simple use of a convolution kernel to modify an image, which is a common technique for image processing. Convolution kernels specify the amount of effect each pixel in the fragment&#8217;s neighborhood should have on its final output value. For example, the kernel used here for sharpen is:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt> 0 -1  0
-1  5 -1
 0 -1  0</tt></pre>
</div></div>
<div class="paragraph"><p>The pixel labeled "5" is the current pixel and the other values are the proportions of the surrounding pixels to use.</p></div>
<div class="paragraph"><p><em>NOTE: It would be conventional (and superior for performance) to declare float arrays before the shader&#8217;s main() function. However, that seems not to work on OSX, so this example sets the values of both of its necessary arrays inside of main() which is bad for performance, but works and is not a problem in this simple example.</em></p></div>
<div class="sect2">
<h3 id="_code_4">Code</h3>
<div class="sect3">
<h4 id="_sharpen_shader_pde">sharpen_shader.pde</h4>
<div class="listingblock">
<div class="content">
<pre><tt>import processing.opengl.*;
import codeanticode.glgraphics.*;

GLTexture face;
GLTexture output;
GLTextureFilter sharpen;

int w = 640;
int h = 480;

void setup() {
  size(w * 2, h, GLConstants.GLGRAPHICS);

  face = new GLTexture(this, "face.jpg");
  output = new GLTexture(this, w, h);
  sharpen = new GLTextureFilter(this, "sharpen.xml");
}

void draw() {
  sharpen.setParameterValue("imgWidth", float(w));
  sharpen.setParameterValue("imgHeight", float(h));
  sharpen.apply(face, output);
  image(face, 0, 0);
  image(output, w, 0);
}</tt></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_sharpen_frag">sharpen.frag</h4>
<div class="listingblock">
<div class="content">
<pre><tt>uniform sampler2D src_tex_unit0;
uniform float imgWidth;
uniform float imgHeight;

// NOTE: we should initialize these arrays up here
//               but that syntax doesn't work on OSX for some reason
//               so we set these array values in main(), which
//       is bad for performance, but works on OSX

float kernel[9];
vec2 offset[9];

float step_w = 1.0/imgWidth;
float step_h = 1.0/imgHeight;

void main() {
        offset[0] = vec2(-step_w, -step_h);
        offset[1] = vec2(0.0, -step_h);
        offset[2] = vec2(step_w, -step_h);
        offset[3] = vec2(-step_w, 0.0);
        offset[4] = vec2(0.0, 0.0);
        offset[5] = vec2(step_w, 0.0);
        offset[6] = vec2(-step_w, step_h);
        offset[7] = vec2(0.0, step_h);
        offset[8] = vec2(step_w, step_h);


        /* SHARPEN KERNEL
         0 -1  0
        -1  5 -1
         0 -1  0
        */

        kernel[0] = 0.;
        kernel[1] = -1.;
        kernel[2] = 0.;
        kernel[3] = -1.;
        kernel[4] = 5.;
        kernel[5] = -1.;
        kernel[6] = 0.;
        kernel[7] = -1.;
        kernel[8] = 0.;

        vec4 sum = vec4(0.0);
        int i;

        for (i = 0; i &lt; 9; i++) {
                vec4 color = texture2D(src_tex_unit0, gl_TexCoord[0].st + offset[i]);
                sum += color * kernel[i];
        }

        gl_FragColor = sum;
}</tt></pre>
</div></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_contrast_shader">Contrast Shader</h2>
<div class="sectionbody">
<div class="paragraph"><p>This shader adds or remove contrast from an image. See the results <a href="http://www.flickr.com/photos/unavoidablegrain/7336797536/in/photostream">here</a>. This shader could also be trivially modified to control the saturation of the image.</p></div>
<div class="sect2">
<h3 id="_code_5">Code</h3>
<div class="sect3">
<h4 id="_contrast_shader_pde">contrast_shader.pde</h4>
<div class="listingblock">
<div class="content">
<pre><tt>import processing.opengl.*;
import codeanticode.glgraphics.*;

GLTexture face;
GLTexture output;
GLTextureFilter contrast;

int w = 640;
int h = 480;

void setup() {
  size(w * 2, h, GLConstants.GLGRAPHICS);

  face = new GLTexture(this, "face.jpg");
  output = new GLTexture(this, w, h);
  contrast = new GLTextureFilter(this, "contrast.xml");
}

void draw() {
  contrast.setParameterValue("imgWidth", float(w));
  contrast.setParameterValue("imgHeight", float(h));
  contrast.setParameterValue("contrast", map(mouseX, 0, w/2, 0, 1));
  contrast.apply(face, output);
  image(face, 0, 0);
  image(output, w, 0);
  fill(255);
  text("mouse left-right to set contrast: " + map(mouseX, 0, w/2, 0, 1), 5, height-15);
}</tt></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_contrast_frag">contrast.frag</h4>
<div class="listingblock">
<div class="content">
<pre><tt>uniform sampler2D src_tex_unit0;
uniform float imgWidth;
uniform float imgHeight;
uniform float contrast;

float step_w = 1.0/imgWidth;
float step_h = 1.0/imgHeight;

void main() {
        vec3 color = vec3(texture2D(src_tex_unit0, gl_TexCoord[0].st));
        const vec3 LumCoeff = vec3(0.2125, 0.7154, 0.0721);

        vec3 AvgLumin = vec3(0.5, 0.5, 0.5);

        vec3 intensity = vec3(dot(color, LumCoeff));

        // could substitute a uniform for this 1. and have variable saturation
        vec3 satColor = mix(intensity, color, 1.);
        vec3 conColor = mix(AvgLumin, satColor, contrast);

        gl_FragColor = vec4(conColor, 1);
}</tt></pre>
</div></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hatch_effect_shader">Hatch Effect Shader</h2>
<div class="sectionbody">
<div class="paragraph"><p>This shader was ported by <a href="http://unlekker.net/">Marius Watz</a> from <a href="http://meshlab.sourceforge.net/">Meshlab</a>.</p></div>
<div class="paragraph"><p>Currently, the vertex shader fails to successfully calculate the normal between the light and each vertex which makes the light appear to move around as the spheres spin. This is a bug.</p></div>
<div class="sect2">
<h3 id="_code_6">Code</h3>
<div class="sect3">
<h4 id="_hatchshader_pde">hatchShader.pde</h4>
<div class="listingblock">
<div class="content">
<pre><tt>import processing.opengl.*;
import codeanticode.glgraphics.*;

GLSLShader vertexShader;

void setup() {
  size(800, 800, GLConstants.GLGRAPHICS);

  vertexShader = new GLSLShader(this,
  "Hatch.vert", "Hatch.frag");
  noStroke();
}

float y = 0;

void draw() {
  background(0);
  fill(255, 255*0.5, 0);

  pointLight(100, 200, 100, 0, 1, 1);
  pointLight(100, 200, 100, 0, 0, -1);

  sphereDetail(60);
  pushMatrix();
  translate(width/2, height/2, 0);
  rotateX(HALF_PI+(y+=0.02));
  rotateY(y);

  vertexShader.start();

  vertexShader.setFloatUniform("frequency", map(mouseX, 0, width, 0.5, 3));
  vertexShader.setFloatUniform("edgew", map(mouseY, 0, height, 0, 1));
  vertexShader.setVecUniform("HatchDirection", 0, 0.5f, 0.5f);
  vertexShader.setFloatUniform("Lightness", 0.2f);

  scale(1.2);
  translate(-100, 100, -50);
  sphere(150);
  translate(200, 0, 0);
  sphere(150);
  translate(-100, -200, 0);
  sphere(150);
  vertexShader.stop();

  popMatrix();
}</tt></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_hatch_vert">Hatch.vert</h4>
<div class="listingblock">
<div class="content">
<pre><tt>/****************************************************************************
* MeshLab                                                           o o     *
* An extendible mesh processor                                    o     o   *
*                                                                _   O  _   *
* Copyright(C) 2005, 2009                                          \/)\/    *
* Visual Computing Lab                                            /\/|      *
* ISTI - Italian National Research Council                           |      *
*                                                                    \      *
* All rights reserved.                                                      *
*                                                                           *
* This program is free software; you can redistribute it and/or modify      *
* it under the terms of the GNU General Public License as published by      *
* the Free Software Foundation; either version 2 of the License, or         *
* (at your option) any later version.                                       *
*                                                                           *
* This program is distributed in the hope that it will be useful,           *
* but WITHOUT ANY WARRANTY; without even the implied warranty of            *
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             *
* GNU General Public License (http://www.gnu.org/licenses/gpl.txt)          *
* for more details.                                                         *
*                                                                           *
****************************************************************************/

uniform vec3  HatchDirection;
uniform float Lightness;

varying vec3  ObjPos;
varying float V;
varying float LightIntensity;

void main()
{
    ObjPos          = vec3(gl_Vertex) * 0.2;

    vec3 pos        = vec3(gl_ModelViewMatrix * gl_Vertex);
    vec3 tnorm      = normalize(gl_NormalMatrix * gl_Normal);
    //vec3 lightVec   = normalize(LightPosition - pos);
        vec3 lightVec =  normalize(vec3(gl_LightSource[0].position));

    float grey = Lightness*dot (vec4(.333,.333,.333,0),gl_Color);
        LightIntensity  = max(grey * dot(lightVec, tnorm), 0.0);
        LightIntensity  = max(dot(lightVec, tnorm), 0.0);

    //V = gl_MultiTexCoord0.t;  // try .s for vertical stripes
        V =dot(vec3(gl_Vertex),HatchDirection);

    gl_Position = ftransform();
//    gl_FrontColor=gl_Color;
}</tt></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_hatch_frag">Hatch.frag</h4>
<div class="listingblock">
<div class="content">
<pre><tt>/****************************************************************************
* MeshLab                                                           o o     *
* An extendible mesh processor                                    o     o   *
*                                                                _   O  _   *
* Copyright(C) 2005, 2009                                          \/)\/    *
* Visual Computing Lab                                            /\/|      *
* ISTI - Italian National Research Council                           |      *
*                                                                    \      *
* All rights reserved.                                                      *
*                                                                           *
* This program is free software; you can redistribute it and/or modify      *
* it under the terms of the GNU General Public License as published by      *
* the Free Software Foundation; either version 2 of the License, or         *
* (at your option) any later version.                                       *
*                                                                           *
* This program is distributed in the hope that it will be useful,           *
* but WITHOUT ANY WARRANTY; without even the implied warranty of            *
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             *
* GNU General Public License (http://www.gnu.org/licenses/gpl.txt)          *
* for more details.                                                         *
*                                                                           *
****************************************************************************/

uniform float frequency;
uniform float edgew;            // width of smooth step

varying vec3  ObjPos;               // object space coord (noisy)
varying float V;                    // generic varying
varying float LightIntensity;


void main()
{
    float dp       = length(vec2(dFdx(V), dFdy(V)));
    float logdp    = -log2(dp * 8.0);
    float ilogdp   = floor(logdp);
    float stripes  = exp2(ilogdp);

    float sawtooth = fract((V ) * frequency * stripes);
    float triangle = abs(2.0 * sawtooth - 1.0);

    // adjust line width
    float transition = logdp - ilogdp;

    // taper ends
    triangle = abs((1.0 + transition) * triangle - transition);


    float edge0  = clamp(LightIntensity - edgew, 0.0, 1.0);
    float edge1  = clamp(LightIntensity, 0.0, 1.0);
    float square = 1.0 - smoothstep(edge0, edge1, triangle);

// uncomment this line to get the original color instead of white
 //  gl_FragColor = gl_Color * vec4(vec3(square), 1.0);

   gl_FragColor =  vec4(vec3(square), 1.0);
}</tt></pre>
</div></div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2012-06-04 12:54:56 EDT
</div>
</div>
</body>
</html>
